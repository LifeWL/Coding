# 设计模式

## UML

---

- UML(United Modeling Language, 统一建模语言)：是一种基于面向对象的可视化建模语言
- UML采用了一组形象化的图形（如类图）符号作为建模语言，使用这些符号可以形象地描述系统的各个方面
- UML通过建立图形之间的各种关系（如类与类之间的关系）来描述模型
- UML10种图对比

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled.png)

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%201.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%201.png)

- 用例图（Use Case Diagram）
    - 用例图也称为用户模型图，是从软件需求分析到最终实现的第一步，它是从客户的角度来描述系统功能
    - 用例图包含3个基本组件：

        参与者（Actor）：与系统打交道的人或其他系统即使用该系统的人或事物

        用例（Use Case）：代表系统的某项完整的功能。

        关系：定义用例之间的关系——泛化关系，扩展关系，包含关系

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%202.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%202.png)

    - 用例之间的关系——泛化关系

        表示同一业务目的（父用力）的不同技术实现（各个子用例）。在UML中，用例泛化用一个三角箭头从子用例指向父用例。**子用例继承自父用例。**

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%203.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%203.png)

    - 用例之间的关系——包含关系

        一个用例可以包含其他用例具有的行为，并把它包含的用例行为作为自身行为的一部分。在UML中包含关系用虚线箭头加`<<include>>`，箭头指向被包含的用例。被包含的用例被其他用例调用。

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%204.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%204.png)

    - 用例之间的关系——扩展关系

        如果在完成某个功能的时候**偶尔会执行另外一个功能**，则用扩展关系表示。在UML中扩展关系用虚线箭头加 `<<extend>>` ，箭头指向被扩展的用例。某一个用例可能会触发另一个用例。

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%205.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%205.png)

    - 用例图练习

        想想是关于一个公司的人事管理系统的需求的简单描述，建立其相应的用例模型：该人事管理系统的用户是公司的人事管理干部，该系统具有人事档案库，**保存员工的人事信息**，包括姓名，性别，出生年月，健康状况，文化成都，学位，职位，岗位，聘任时间，任期，工资， 津贴，奖罚记录，业绩，论著和家庭情况等，系统提供的基本服务有**人事信息的管理**，包括人事的调动与聘任，职称评定，奖罚等，并且可以**查询人事信息**，**生成与输出统计报表**等， 该人事系统每月向公司的财务人员**提供员工的工资，津贴等数据**。

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%206.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%206.png)

- 类图（Class Diagram）

    类图是面向对象系统建模中最常用的图，是定义其他图的基础

    类图主要是用来显示系统中的类，借口以及它们之间的关系

    类图包含的主要元素有类，接口和关系。其中关系有泛化关系，关联关系，依赖关系和实现关系。在类图中可包含**注释和约束**

    - 类的表示方法
        1. 类是类图中的主要组件，由3部分 组成 ：类名，属性和方法。 在UML中，类用举行来表示，顶端 部分 存放 类的名称 ，中间部分存放类的属性 ，属性的类型及值，底部部分存放类的方法，方法的参数和返回值

            ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%207.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%207.png)

        2. 在UML中课根据实际情况有选择地隐藏属性部分或方法部分或两者都隐藏

            ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%208.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%208.png)

        3. 在UML中，共有类型用+表示，私有类型用-表示，保护类型用#表示，UML的工具开发商可以使用自己定义的符号表示不同的可见性。
    - 类之间的关系——泛化关系
        1. 在UML中，**泛化关系用来表示类与类，接口与接口之间的继承关系**。泛化关系有时也称为**“is  a kind of"**关系
        2. 在UML中泛化关系用一调实线空心箭头由子类指向父类

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%209.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%209.png)

    - 类之间的关系——实现关系

        在UML中，**实现关系用来表示类与接口之间的实现关系**。

        在UML中，实现关系用一条虚线空心箭头由子类指向父类

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2010.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2010.png)

    - 类之间的关系——依赖关系

        对于两个相对独立的系统，**当一个系统负责构造另一个系统的实例，或者依赖另一个系统的服务时，这两个系统之间体现为依赖关系**。

        体现在代码上就是一个类在内部实例化另一个类的实例（不是成员变量），用来当作成员函数形参，返回值。

    - 类之间的关系——关联关系

        对于两个相对独立的系统，当一个系统内将另一个系统的实例当作自己的成员变量时，这两个系统之间体现为关联关系

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2011.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2011.png)

    - 类之间的关系——关联——聚合
        1. 聚合关系是关联关系的一种，是更强的关联关系。
        2. 聚合是整体和部分之间的关系，例如汽车由引擎、轮胎以及其他零件组成
        3. 聚合关系也是通过成员变量来实现的。但是，**关联关系所设计的两个类处在同一个层次上，** 而**聚合关系中，两个类处于不同的层次上，一个代表整体，一个代表部分**。

            ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2012.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2012.png)

    - 类之间的关系——关联——组合
        1. UML类图关系中组合关系是关联关系的一种，是比聚合关系还要强的关系。
        2. **代表整体的对象负责代表部分对象的生命周期**

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2013.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2013.png)

    - 练习

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2014.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2014.png)

- 时序图（Sequence Diagram）

    时序图用与描述对象之间的传递消息的时间顺序，即用例中的行为顺序

    当执行一个用例时，时序图的每条消息对应了一个类操作或者引起转换的触发时间

    在UML中，时序图表示为一个二维的关系图，其中，纵轴是时间轴，实线沿竖线向下延伸，横轴代表在协作中各个独立的对象。当对象存在时，生命线以一条虚线表示，消息用从一个对象的生命线到另一个对象的生命线的箭头表示。箭头以时间的顺序在图中上下排列。

    - 借书时序图

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2015.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2015.png)

    - ATM用户成功登录时序图

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2016.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2016.png)

- 活动图（Activity Diagram）

    在UML中，活动图本质上就是流程图。它用于描述系统的活动，判定点和分支等。

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2017.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2017.png)

    - 基本概念

        **动作状态：**原子的，不可中断的动作，并在此动作完成之后向另一个动作转变。在UML中动作状态用圆角举行表示，动作状态所表示的动作写在圆角矩形内部。

        **分支与合并：**分支在软件系统中很常见。一般用于表示对象类所具有的条件行为。用一个不二型表达式的真假来判定动作的流向。条件行为用分支和合并表达。在活动图中，分支用空心小菱形表示。分支包括一个入转换和两个带条件的出转换，出转换的条件应该是互斥的，必须保证只有一条出转换能够被处罚，合并包含两个带条件的入转换和一个出转换。

        **分叉与汇合：**分叉用来描述并发线程，每个分叉可以有一个输入转换和两个或多个输出转换。每个转换都可以是独立的控制流。汇合代表两个或多个并发控制流同步发生，当所有的控制流都大道汇合点后，控制才能继续往下进行。每个汇合可以有两个或多个输入转换和一个输出转换。在UML中分叉和汇合用一条粗直线表示。

        **泳道：**泳道将活动图中的活动划分为若干组，并将每一组指定给负责这组活动的业务组织。泳道区分负责活动的对象，明确地表示哪些活动是由哪些对象进行的。每个活动指定明确地属于一个泳道。在活动图中，泳道用垂直实线长绘出，垂直线分隔的区域即为泳道。

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2018.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2018.png)

- 状态图（StateChart Diagram）
    - 进程的状态机

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2019.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2019.png)

- 协作图（Collabration Diagram）

    协作图（也叫合作图）是一种交互图

    时序图主要侧重于对象间消息传递在时间上的先后关系，而协作图表达对象间的交互过程及对象间的关联关系。可读性差，被时序图取代。

    - 借书协作图

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2020.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2020.png)

    - 登录协作图

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2021.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2021.png)

- 对象图（Object Diagram）

    对象图是类图的一个实例，用于显示系统执行时的一个可能的快照，即在某一个时间上系统可能出现的样子。对象图带下划线的对象名称来表示对象。现在已经被类图代替。

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2022.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2022.png)

- 包图（Package Diagram）

    **包图由包和包之间的关系组成。**包的图标就如同一个带标签的文件夹。**包提供了一种用于组织各种元素的分组机制。**在UML中，包用来对元素进行分组，并为这些元素提供命名空间。包所拥有的或者吨不用的所有元素称为包的内容，包没有实例 。

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2023.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2023.png)

- 组件图（Compenent Diagram）

    组件图用来建立系统中各组件之间的关系，各组件通过功能组织在一起。

    Javabean, ejb, jsp都是组件。在UML中，组件使用在左侧有两个小矩形的大矩形来表示。

    组件图可以用来设计系统的整体架构。

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2024.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2024.png)

- 部署图（Deployment Diagram）

    部署图用来帮助开发者了解软件中的各个组件驻留在什么硬件位置，以及这些硬件之间的交互关系。

    节点：用来表示一种硬件，可以是打印机，计算机等。节点的标记符号是一个三围框，在框的坐上方包含了节点的名称。

    通信关联：节点通过通信关联建立彼此的关系，采用从节点到节点绘制实线来表示关联。

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2025.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2025.png)

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2026.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2026.png)

## 设计模式概述

---

- 设计模式概念

    在一定环境下，用固定套路解决问题

- 设计模式种类

    GOF设计模式有23个，包括

    创建型（Creationl）模式：如何创建对象

    结构型（Structural）模式：如何实现类或对象的组合

    行为型（Behavioral）模式：类或对象怎样交互以及怎样分配职责

    有一个“简单工厂模式“不属于这23种设计模式，但很常用，也即一共有24种设计模式

- 设计模式作用

    学习设计模式将有助于更加深入地理解面向对象思想，让你知道：

    1. 如何将代码分散在几个不同的类中？
    2. 为什么要有“接口”？
    3. 何谓针对抽象编程？
    4. 何时不应该使用继承？
    5. 如果不修改源代码增加新功能？
    6. 更好地阅读和理解现有类库与其他系统中的源代码？
- 如何学好设计模式

    设计模式的基础是：多态（继承，虚函数重写，父类指针引用子类对象）

    初学者：积累案例，不要盲目的背类图

    初级开发人员：多思考，多梳理，归纳总结，尊重失误的认知规律，注意临界点的突破，不要浮躁。

    中级开发人员：合适的开发环境，寻找合适的设计模式来解决问题。多应用，对经典组合设计模式的大量，自由的运用。要不断的追求。

- 设计模式总览

    6种创建型模式（单例模式、简单工厂模式、工厂方法模式、抽象工厂模式、原型模式、建造者模式）

    7种结构型模式（适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式）

    11种行为型模式（职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式）

## 面向对象设计原则

---

- 原则目的：高内聚，低耦合
- 对于面向对象软件系统的设计而言，在只可维护性的同时，提高系统的可服用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。没一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水瓶。
- 面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式踹的使用效果重要指标之一。
- 单一职责原则（类的职责单一）（Single Responsibility Principle, SRP）

    类的职责单一，对外只提供一种功能，引起类变化的原因都应该只有一个

    ```cpp
    class Clothes
    {
    public:
    	void shopping(){
    	cout << "休闲的服装" << endl;
    	}
    	void working(){
    		cout << "正式的服装" << endl;
    	}
    };

    int main(void)
    {
    	//工作中
    	Clothes c1;
    	c1.working();

    	//逛街中
    	c1.shopping();

    	return 0;
    }
    ```

    通过修改其中一个方法， 在一定环境下，可能会影响到其他方法的功能。（不同方法之间存在耦合）

    ```cpp
    class ClothesShopping
    {
    	public:
    		void style(){
    			cout <<  "休闲的服装" << endl;
    		}
    }

    class ClothesWorking
    {
    	public:
    		void style(){
    			cout << "正式的服装" << endl;
    		}
    }

    int main(void)
    {
    	//工作中
    	ClothesShopping cs;
    	cs.style();

    	//逛街中
    	ClothesWorking cw;
    	cw.style();
    }
    ```

    如果将每个类的方法分离出来，就能保证每个类的职责单一，提高了全性和可维护性

- 开闭原则（扩展开放，修改关闭）（Open-Closed Principle, OCP）

    类的改动是通过增加代码进行的，而不是修改源代码。

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2027.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2027.png)

    ```cpp
    class Banker
    {
    public:
    	void save(){
    		cout << "存款" << endl;
    	}
    	void pay(){
    		cout << "支付" << endl;
    	}
    	void transfer(){
    		cout << "转账" << endl;
    	}
    	// 这样设计要在类里增加需求
    	void fund(){
    		cout << "办理基金" << endl;
    	}
    };
    int main(void)
    {
    	Banker b;

    	// 存款
    	b.save();
    	b.transfer();
    	// 新的办理基金需求
    	b.fund();
    	return 0;
    }
    ```

    下面的设计不仅满足了开闭原则，还满足了单一职责原则，之前写好的代码就不用动了，提高了可维护性和安全性，可读性，可复用性。

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2028.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2028.png)

    ```cpp
    //抽象类
    class AbstractBanker
    {
    public:
    	virtual void work() = 0; // 抽象的接口
    };

    //存款
    //多态三条件之一：继承
    class SaveBanker:public AbstractBanker{
    public:
      //多态三条件之二：虚函数重写
    	virtual void work(){
    		cout << "存款" << endl;
    	}
    };

    //转账
    class TransferBanker:public AbstractBanker{
    public:
    	virtual void work(){
    		cout << "转账" << endl;
    	}
    };

    //支付
    class PayBanker:public AbstractBanker{
    public:
    	virtual void work(){
    		cout << "支付" << endl;
    	}
    };

    //办理基金
    class FundBanker:public AbstractBanker{
    public:
    	virtual void work(){
    		cout << "基金" << endl;
    	}
    };

    int main(void)
    {
    	//存款
    	//多态三条件之三，父类指针引用子类对象
    	AbstractBanker *sb = new SaveBanker;
    	sb->work();
    	delete sb;

    	//转账 
    	AbstractBanker *tb = new TransBanker;
    	tb->work();
    	delete tb;
    	
    	//支付
    	AbstractBanker *pb = new PayBanker;
    	pb->work();
    	delete pb;

    	// 基金
    	AbstractBanker *fb = new FundBanker;
    	fb->work();
    	delete fb;

    	return 0;
    }
    ```

- 里氏代换原则（多写抽象类）（Liskov Substitution Principle, LSP）

    任何抽象类出现的地方都课用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。（就是鼓励使用多态，多写抽象类）

- 依赖倒转原则（面向接口/抽象编程）（Dependence Inversion Principle, DIP）

    依赖于抽象（接口），不要依赖具体的实现（类），也就是面向接口编程。

    实现业务逻辑时，只需要关注抽象层的接口，不需要关注实现层每个接口的具体实现。

    - 司机开车

        下面的实现，ZhangSan依赖Benz对象，两者是依赖关系（ZhangSan类内没有Benz实例成员）

        这里的问题有两个，一个是相同对象之间没有抽象成类，二是类方法用到了别的类的对象，也要抽象成基类，这样通过两个基类就能实现很多组合。

        ```cpp
        class Benz
        {
        public:
        	void run(){
        		cout << "奔驰启动了" << endl;
        	}
        };

        class BMW
        {
        public:
        	void run(){
        		cout << "宝马启动了" << endl;
        	}
        };

        class ZhangSan
        {
        public:
        	void driveBenz(Benz *b){
        		b->run();
        	}
        	void driveBMW(BMW *b){
        		b->run();
        	}
        };

        Class LiSi
        {
        public:
        	void driveBenz(Benz *b){
        		b->run();
        	}
        	void driveBMW(BMW *b){
        		b->run();
        	}
        };

        //业务
        int main(void)
        {
        	//张三去开奔驰
        	Benz* benz = new Benz;
        	ZhangSan *zs = new ZhangSan;
        	zs->driveBenz(benz);

        	//李四去开宝马
        	BMW* bmw = new BMW;
        	LiSi *ls = new LiSi;
        	ls->dirveBMW(bmw);

        	return 0;
        }
        ```

        将业务层和实现层通过抽象层隔离（解耦合），实现层也通过多态技术抽象成类

        ```cpp
        //---------抽象层-----------

        Class Car{
        public:
        	virtual void run() = 0;
        };

        class Dirver{
        public:
        	virtual void drive(Car *car) = 0;
        };

        //---------实现层-----------
        Class ZhangSan:public Driver{
        public:
        	virtual void drive(Car *car)
        	{
        		cout << "张三开车了" << endl;
        		car->run();
        	}
        };

        Class LiSi:public Driver{
        public:
        	virtual void drive(Car *car)
        	{
        		cout << "李四开车了" << endl;
        		car->run();
        	}
        };

        Class Benz:public Car{
        public:
        	virtual void run(){
        		cout << "开的是奔驰" << endl;
        	}
        };

        Class BMW:public Car{
        public:
        	virtual void run(){
        		cout << "开的是宝马" << endl;
        	}
        };

        //----------高层业务------------
        int main()
        {
        	//张三开奔驰
        	Car* benz = new Benz;
        	Driver* ZhangSan = new ZhangSan;
        	ZhangSan->drive(benz);

        	//李四开宝马
        	Car* bmw = new BMW;
        	Driver* LiSi = new Lisi;
        	LiSi->drive(bmw);
        }
        ```

    - 电脑组装

        抽象出三个组件类，一个架构类，内部封装方法。实现层实现具体方法。业务层实现具体逻辑。

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2029.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2029.png)

        ```cpp
        //-------抽象层--------
        class CPU()
        {
        public:
        	virtual void caculate() = 0;
        };

        class Card
        {
        public:
        	virtual void display() = 0;
        };

        class Memory
        {
        public:
        	virtual void storage() = 0;
        };

        //架构类
        class Computer
        {
        public:
        	Computer(CPU *cpu, Card *card, Memory *mem){
        		this->cpu = cpu;
        		this->card = card;
        		this->mem = mem;
        	}
        	
        	void work(){
        		cpu->caculate();
        		card->display();
        		mem->storage();
        	}
        private:
        	CPU *cpu;
        	Card *card;
        	Memory *mem;
        };

        //--------实现层---------
        class IntelCPU:public CPU{
        	virtual void caculate()
        	{
        		cout << "Intel的CPU工作了" << endl;
        	}
        };

        class NvidiaCard:public Card{
        	virtual void display()
        	{
        		cout << "Nvidia的显卡工作了" << endl;
        	}
        };

        class WDMem:public Mem{
        	virtual void storage()
        	{
        		cout << "西数的内存工作了" << endl;
        	}
        };

        //-------高层业务-------
        int main()
        {
        	CPU *cpu = new IntelCPU;
        	Card *card = new NvidiaCard;
        	Memory *mem = new WDMem;
        	Computer *com = new Copmuter(cpu, car, mem);

        	com->work();

        	//不是类成员，需要手动回收内存
        	delete cpu;
        	delete card;
        	delete mem;
        	delete com;
        	return 0;
        }
        ```

- 接口隔离原则（接口的单一职责）（Interface Segregation Principle, ISP）

    不应该强迫用户的出现依赖他们不需要的接口方法。一个借口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。

    与单一职责类似，可以理解为接口的单一职责原则

- 合成复用原则（组合代替继承）（Composite Reuse Principle, CRP）

    **如果使用继承，会导致父类的任何变化都可能影响到子类的行为。**如果使用对象组合，就降低了这种依赖关系。**对于继承和组合，优先使用组合，**包括（依赖，关联，聚合，组合四种关系）

    如果使用继承方式，那么新的子类将会和所有的父类高耦合。

    ```cpp
    class Cat
    {
    public:
    	void sleep(){
    		cout << "小猫睡觉了" << endl;
    	}
    };

    //想给猫添加一个功能，创建一个新的猫，即能睡觉，又能吃东西
    class AdvCat:public Cat
    {
    public:
    	void eatAndSleep(){
    		cout << "吃东西" << endl;
    		sleep();
    };

    int main(void)
    {
    	Cat c;
    	c.sleep();
    	
    	cout << "----------" << endl;

    	AdvCat ac;
    	ac.eatAndSleep();

    	return 0;
    }
    ```

    如果使用组合（关联）方式，也可以在原来类基础添加新方法，而且只用到了原来类中的sleep()方法，只要该方法不出错即可，降低了新的类与原来的类的耦合度，且与其父类没有任何关系。

    ```cpp
    class Cat
    {
    public:
    	void eatAndSleep(){
    		cout << "" << endl;
    		sleep();
    	}
    };

    class AdvCat
    {
    public:
    	AdvCat(Cat *cat)
    	{
    		this->cat = cat;
    	}
    	
    	void eadAndSleep(){
    		cout << "吃东西" << endl;
    		cat->sleep();
    	}
    };
    private:
    	Cat *cat;
    };

    int main(void)
    {
    	Cat c;
    	c.sleep();
    	
    	cout << "------------" << endl;

    	AdvCat ac(&c);
    	ac.eatAndSleep();

    	return 0;
    }
    ```

- 迪米特法则（知道最少原则）（Law of Demeter,  LoD）

    一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个妙手空空内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理）

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2030.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2030.png)

    采用中介的形式，可以使每个模块之间的耦合度降低，测试的任务量也大大减少。

    ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2031.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2031.png)

## 创建型模式

---

- 简单工厂模式
    - 水果类

        先看下面一段程序

        ```cpp
        class Fruit
        {
        public:
        	//随着水果种类的增加，构造函数越来越复杂
        	Fruit(string kind)
        	{
        		this->kind = kind;
        		if (kind == "apple"){
        			//苹果的初始化
        		}
        		else if (kind == "banana"){
        			//香蕉的初始化
        		}
        	}

        	void getName(){
        		if (this->kind == "apple"){
        			cout << "我是苹果" << endl;
        		}
        		else if (this->kind == "banana"){
        			cout << "我是香蕉" << endl;
        		}
        	}

        private:
        	string kind; //水果种类
        };

        int main(void)
        {
        	//main函数跟Fruit类的构造函数耦合度高
        	Fruit *apple = new Fruit("apple");
        	apple->getName();
        	delete apple;
        	
        	return 0;
        }
        ```

        问题如下：

        (1) 在Fruit类中包含很多“if…else…”代码块，整个类的代码相当冗长，
        代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在
        还将影响系统的性能，程序在执行过程中需要做大量的条件判断。
        (2) Fruit类的职责过重，它负责初始化和显示所有的水果对象，将各种水
        果对象的初始化代码和显示代码集中在一个类中实现，违反了“单一职责原
        则”，不利于类的重用和维护；
        (3) 当需要增加新类型的水果时，必须修改Fruit类的源代码，违反了“开
        闭原则”。

        构造函数只做初始化工作，不写业务

        可以用工厂对上述代码进行改造

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2032.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2032.png)

        通过工厂将人们和水果分开，即符合单一职责规则（每个类负责一种水果的初始化，工厂内只只负责生产水果），也符合开闭原则，面向接口编程原则（新水果重写水果类的方法接口即可）

        ```cpp
        //抽象的水果类，供具体水果实现，和工厂使用
        class Fruit
        {
        public:
        	virtual void getName() = 0;
        };

        class Apple:public Fruit
        {
        public:
        	virtual void getName(){
        		cout << "我是苹果" << endl;
        	}
        };

        class Banana:public Fruit
        {
        public:
        	virtual void getName(){
        		cout << "我是香蕉" << endl;
        	}
        };

        //添加一个新产品 鸭梨
        class Pear:public Fruit
        {
        public:
        	virtual void getName(){
        		cout << "我是鸭梨" << endl;
        	}
        };

        //工厂
        class Factory{
        public:
        	//水果生产器
        	Fruit* createFruit(string kind){
        		Fruit *fruit = NULL;
        		if (kind == "apple"){
        			fruit =  new Apple;
        		}
        		else if (kind == "banana"){
        			fruit =  new Banana;
        		}
        		//添加一个鸭梨，修改了工厂的代码，违背了开闭原则
        		else if (kind == "pear"){
        			fruit = new Pear;
        		}
        		return fruit;
        };

        int main(void)
        {
        	//人们和工厂打交道
        	Factory *factory = new Factory;
        	//给我来一个苹果
        	Fruit *apple = factory->createFruit("apple");
        	apple->getName();

        	Fruit *banana = factory->createFruit("banana");
        	banana->getName();

        	Fruit *pear = factory->createFruit("pear");
        	pear->getName();
        	
        	// 工厂只负责生产，不负责回收内存
        	delete apple;
        	delete banana;
        	delete factory;

        	return 0;
        }
        ```

    - 模式中的角色和职责

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2033.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2033.png)

        工厂（Factory）角色：简单工厂模式的核心，它负责实现创建所有实例
        的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。
        抽象产品（AbstractProduct）角色：简单工厂模式所创建的所有对象的
        父类，它负责描述所有实例所共有的公共接口。
        具体产品（Concrete Product）角色：简单工厂模式所创建的具体实例
        对象。

    - 简单工厂模式的优缺点

        优点：

        1. 实现了对象创建和使用的分离。
        2. 不需要记住具体类名，记住参数（标签）即可，减少使用者记忆量。

        缺点：

        1. 对工厂类职责过重，一旦不能工作，系统受到影响。
        2. 增加系统中类的个数，复杂度和理解度增加。
        3. 违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂。
    - 适用场景
        1. 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂
        方法中的业务逻辑太过复杂。
        2. 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。
- 工厂方法模式
    - 引入抽象工厂改进水果类

        引入一个抽象工厂类来解决简单工厂模式中，工厂不满足开闭原则的问题

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2034.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2034.png)

        ```cpp
        class Fruit
        {
        public:
        	virtual void getName() = 0;
        };

        class Apple:public Fruit
        {
        public:
        	virtual void getName(){
        		cout << "我是苹果" << endl;
        	}
        };

        class Banana:public Fruit
        {
        public:
        	virtual void getName(){
        		cout << "我是香蕉" << endl;
        	}
        };

        //添加一个梨产品
        class Pear:public Fruit
        {
        public:
        	virtual void getName(){
        		cout << "我是鸭梨" << endl;
        	}
        };

        //抽象的工厂类
        class AbstractFactory
        {
        public:
        	virtual Fruit* createFruit() = 0;
        };

        //苹果工厂
        class AppleFactory:public AbstractFactory
        {
        public:
        	virtual Fruit* createFruit(){
        		//return &Apple(); 局部变量在栈空间上，析构会被回收
        		return new Apple; //开辟堆空间，避免析构回收栈空间
        	}
        };

        //香蕉工厂
        class BananaFactory:public AbstractFactory
        {
        public:
        	virtual Fruit* createFruit(){
        		return new Banana;
        	}
        };

        //鸭梨工厂
        class BearFactory:public AbstractFactory
        {
        public:
        	virtual Fruit* createFruit(){
        		return new Bear;
        	}
        };

        int main(void)
        {
        	AbstractFactory* appleFactory = new AppleFactory;
        	Fruit *apple = appleFactory->createFruit();
        	apple->getName();

        	AbstractFactory* bananaFactory = new AppleFactory;
        	Fruit *banana = bananaFactory->createFruit();
        	banana->getName();
        	
        	delete bananaFactory;
        	delete banana;

        	delete appleFactory;
        	delete apple;

        	return 0;
        }
        ```

    - 模式中的角色和职责

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2035.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2035.png)

        抽象工厂（Abstract Factory）角色：工厂方法模式的核心，任何工厂类
        都必须实现这个接口。
        具体工厂（Concrete Factory）角色：具体工厂类是抽象工厂的一个实现，
        负责实例化产品对象。
        抽象产品（Abstract Product）角色：工厂方法模式所创建的所有对象
        的父类，它负责描述所有实例所共有的公共接口。
        具体产品（Concrete Product）角色：工厂方法模式所创建的具体实例对象。

        > 简单工厂模式 + “开闭原则” = 工厂方法模式

    - 工厂方法模式的优缺点

        优点：

        1. 不需要记住具体类名，甚至连具体参数都不用记忆。
        2. 实现了对象创建和使用的分离。
        3. 系统的可扩展性也就变得非常好，无需修改接口和原类。

        缺点：

        1. 增加系统中类的个数，复杂度和理解度增加。
        2. 增加了系统的抽象性和理解难度。
    - 使用场景
        1. 客户端不知道它所需要的对象的类。（抽象工厂）
        2. 抽象工厂类通过其子类来指定创建哪个对象。（具体工厂）
- 抽象工厂模式
    - 引入工厂等级结构改进水果类

        工厂方法模式通过引入抽象工厂，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，会增加系统的开销。我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。

        - 产品族和产品等级结构

            如果一系列产品，他们都是来自同一工厂，并且他们拥有各自的功能。就说这一系列产品是一个产品族。

            如果一系列产品，他们具有相同的功能，并且来自不同的工厂，就称这一系列的产品是一个产品等级结构。

            ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2036.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2036.png)

        针对产品族进行添加符合开闭原则

        针对产品等级结构进行添加不符合开闭原则

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2037.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2037.png)

        ```cpp
        class Fruit
        {
        public:
        	virtual void getName() = 0;
        };

        class USAApple:public Fruit
        {
        public:
        	virtual void getName(){
        		cout << "我是美国的苹果" << endl;
        	}
        };

        class USABanana:public Fruit
        {
        public:
        	virtual void getName(){
        		cout << "我是美国的香蕉" << endl;
        	}
        };

        class ChinaApple:public Fruit
        {
        public:
        	virtual void getName(){
        		cout << "我是中国的苹果" << endl;
        	}
        };

        class ChinaApple:public Fruit
        {
        public:
        	virtual void getName(){
        		cout << "我是中国的香蕉" << endl;
        	}
        };

        //新增一个日本产品族
        class JapanApple:public Fruit
        {
        public:
        	virtual void getName(){
        		cout << "我是日本苹果" << endl;
        	}
        };

        class JapanBanana:public Fruit
        {
        public:
        	virtual void getName(){
        		cout << "我是日本梨" << endl;
        	}
        };

        //定义一个面向产品族的抽象工厂
        class AbstractFactory
        {
        public:
        	virtual Fruit* createApple() = 0;
        	virtual Fruit* createBanana() = 0;
        };

        class USAFactory
        {
        public:
        	virtual Fruit* createApple(){
        		return new USAApple;
        	}
        	virtual Fruit* createBanana(){
        		return new USABanana;
        	}
        };

        class ChinaFactory
        {
        public:
        	virtual Fruit* createBanana(){
        		return new ChinaApple;
        	}
        	virtual Fruit* createBanana(){
        		return new ChinaBanana;
        	}
        };

        //若新增一个产品族，满足开闭原则
        //若新增一个产品等级结构，需要在工厂类里增加对应水果的生产器，不满足开闭原则
        class JapanFactory
        {
        public:
        	virtual Fruit* createApple(){
        		return new JapanApple;
        	}
        	virtual Fruit* createBanana(){
        		return new JapanBanana;
        	}
        };

        int main(void)
        {
        	//想要一个美国香蕉
        	//1 来一个美国工厂
        	AbstractFactory* usaFactory = new USAFactory;
        	//2 来一个香蕉
        	Fruit *usaBanana = usaFactory->createBanana();
        	usaBanana->getName();

        	return 0;
        }
        ```

    - 模式中的角色和职责

        ![%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2038.png](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20be568515470c4550a8a6412d79648bed/Untitled%2038.png)

        抽象工厂（Abstract Factory）角色：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。
        具体工厂（Concrete Factory）角色：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。
        抽象产品（Abstract Product）角色：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。
        具体产品（Concrete Product）角色：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。

    - 抽象工厂模式的优缺点

        优点：

        1. 拥有工厂方法模式的优点
        2. 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端
        始终只使用同一个产品族中的对象。
        3. 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。

        缺点：

        1. 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需
        要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。
    - 使用场景
        1. 系统中有多于一个的产品族。而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。
        2. 产品等级结构稳定。设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。
    - 电脑组装作业

        设计一个电脑主板架构，电脑包括（显卡，内存，CPU）3个固定的插口，显卡具有显示功能（display，功能实现只要打印出意义即可）， 内存具有存储功能（storage），cpu具有计算功能（calculate）。
        现有Intel厂商，nvidia厂商，Kingston厂商，均会生产以上三种硬件。
        要求组装两台电脑，
        1台（Intel的CPU，Intel的显卡，Intel的内存）
        1台（Intel的CPU， nvidia的显卡，Kingston的内存）
        用抽象工厂模式实现。

- ‘工厂三兄弟总结
- 单例模式

## 结构型模式

---

- 代理模式
- 装饰器模式
- 外观模式
- 适配器模式

## 行为型模式

---

- 模板方法模式
- 命令模式
- 策略模式
- 观察者模式