# 将单向链表按某值划分成左边小，中间相等，右边大的形式

```C++
# include <iostream>
# include <vector>
using namespace std;

struct list_node{
    int val;
    struct list_node * next;
};

int pivot, n;

list_node * input_list(void)
{
    int val;
    list_node * phead = new list_node();
    list_node * cur_pnode = phead;
    scanf("%d%d", &n, &pivot);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &val);
        if (i == 1) {
            cur_pnode->val = val;
            cur_pnode->next = NULL;
        }
        else {
            list_node * new_pnode = new list_node();
            new_pnode->val = val;
            new_pnode->next = NULL;
            cur_pnode->next = new_pnode;
            cur_pnode = new_pnode;
        }
    }
    return phead;
}

void arrPartition(vector<list_node *>& nodeArr,int pivot, int n) {
  int small = -1;
  int big = n;
  int index = 0;
  while (index != big) {
    if (nodeArr[index]->val < pivot) { 
      ++small;
      swap(nodeArr[small], nodeArr[index]);
      index++;
    } else if (nodeArr[index]->val == pivot) {
      index++;
    } else {
      --big;
      swap(nodeArr[big], nodeArr[index]);
    }
  }
}

list_node * list_partition(list_node * head, int pivot, int n)
{
    //////在下面完成代码
  if (head == NULL) return head;
  list_node *cur = head;
  int i = 0;
  while (cur != NULL) {
    i++;
    cur = cur->next;
  }
  vector<list_node *> nodeArr;
  nodeArr.resize(n+5);
  i = 0;
  cur = head;
  for (i = 0; i != n; i++) {
    nodeArr[i] = cur;
    cur = cur->next;
  }
  arrPartition(nodeArr, pivot, n);
  for (i = 1; i != n; i++) {
    nodeArr[i - 1]->next = nodeArr[i];
  }
  nodeArr[i - 1]->next = NULL;
  for (i = 0; i < n; i++) {
    cout << nodeArr[i]->val << " ";
  }
  return nodeArr[0];
}

int main ()
{
    list_node * head = input_list();
    list_partition(head, pivot, n);
    return 0;
}
```

```C++
进阶解法
# include <bits/stdc++.h>
using namespace std;

struct list_node{
    int val;
    struct list_node * next;
};

int pivot, n;

list_node * input_list(void)
{
    int n, val;
    list_node * phead = new list_node();
    list_node * cur_pnode = phead;
    scanf("%d%d", &n, &pivot);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &val);
        if (i == 1) {
            cur_pnode->val = val;
            cur_pnode->next = NULL;
        }
        else {
            list_node * new_pnode = new list_node();
            new_pnode->val = val;
            new_pnode->next = NULL;
            cur_pnode->next = new_pnode;
            cur_pnode = new_pnode;
        }
    }
    return phead;
}


list_node * list_partition(list_node * head, int pivot)
{
    //////在下面完成代码
  list_node *sH = NULL;
  list_node *sT = NULL;
  list_node *eH = NULL;
  list_node *eT = NULL;
  list_node *bH = NULL;
  list_node *bT = NULL;
  list_node *next = NULL;
  while (head != NULL) {
    next = head->next;
    head->next = NULL;
    if (head->val < pivot){
       if (sH == NULL) {
         sH = head;
         sT = head;
       } else {
         sT->next = head;
         sT= head;
       }
    } else if (head->val == pivot) {
        if (eH == NULL) {
          eH = head;
          eT = head;
        } else {
          eT->next = next;
          eT = head;
        }
    } else {
      if (bH == NULL) {
        bH = head;
        bT = head;
      } else {
        bT->next = head;
        bT = head;
      }
    }
    head = next;
  }
  if (sT != NULL) {
    sT->next = eH;
    eT = eT == NULL ? sT : eT;
  }
  if (eT != NULL) {
    eT->next = bH;
  }
  return sH != NULL ? sH : eH != NULL ? eH : bH;
}


int main ()
{
    list_node * head = input_list();
    list_node * p = list_partition(head, pivot);
    
  while(p){
    cout << p ->val <<" ";
    p=p->next;
   }
    return 0;
}
```

