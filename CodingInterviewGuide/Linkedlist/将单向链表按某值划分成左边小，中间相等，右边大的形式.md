# 将单向链表按某值划分成左边小，中间相等，右边大的形式

```C++
# include <iostream>
# include <vector>
using namespace std;

struct list_node{
    int val;
    struct list_node * next;
};

int pivot, n;

list_node * input_list(void)
{
    int val;
    list_node * phead = new list_node();
    list_node * cur_pnode = phead;
    scanf("%d%d", &n, &pivot);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &val);
        if (i == 1) {
            cur_pnode->val = val;
            cur_pnode->next = NULL;
        }
        else {
            list_node * new_pnode = new list_node();
            new_pnode->val = val;
            new_pnode->next = NULL;
            cur_pnode->next = new_pnode;
            cur_pnode = new_pnode;
        }
    }
    return phead;
}

void arrPartition(vector<list_node *>& nodeArr,int pivot, int n) {
  int small = -1;
  int big = n;
  int index = 0;
  while (index != big) {
    if (nodeArr[index]->val < pivot) { 
      ++small;
      swap(nodeArr[small], nodeArr[index]);
      index++;
    } else if (nodeArr[index]->val == pivot) {
      index++;
    } else {
      --big;
      swap(nodeArr[big], nodeArr[index]);
    }
  }
}

list_node * list_partition(list_node * head, int pivot, int n)
{
    //////在下面完成代码
  if (head == NULL) return head;
  list_node *cur = head;
  int i = 0;
  while (cur != NULL) {
    i++;
    cur = cur->next;
  }
  vector<list_node *> nodeArr;
  nodeArr.resize(n+5);
  i = 0;
  cur = head;
  for (i = 0; i != n; i++) {
    nodeArr[i] = cur;
    cur = cur->next;
  }
  arrPartition(nodeArr, pivot, n);
  for (i = 1; i != n; i++) {
    nodeArr[i - 1]->next = nodeArr[i];
  }
  nodeArr[i - 1]->next = NULL;
  for (i = 0; i < n; i++) {
    cout << nodeArr[i]->val << " ";
  }
  return nodeArr[0];
}

int main ()
{
    list_node * head = input_list();
    list_partition(head, pivot, n);
    return 0;
}
```

