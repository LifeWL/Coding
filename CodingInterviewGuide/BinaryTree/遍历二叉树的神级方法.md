# **遍历二叉树的神级方法**

```C++
#include <iostream>
#include <vector>
#include <stack>


class TreeNode
{
public:
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int val) : val(val), left(NULL), right(NULL) {}

    static void inorderTraversal(TreeNode *root, std::vector<int> &inorder);
    static void preorderTraversal(TreeNode *root, std::vector<int> &preorder);
    static void postorderTraversal(TreeNode *root, std::vector<int> &postorder);
};

void TreeNode::inorderTraversal(TreeNode *root, std::vector<int> &inorder)
{
    if (!root)
        return;

    TreeNode *curr = root;
    std::stack<TreeNode*> temp;

    while(curr || !temp.empty())
    {
        while(curr)
        {
            temp.push(curr);
            curr = curr->left;
        }
        curr = temp.top();
        temp.pop();
        inorder.push_back(curr->val);
        curr = curr->right;
    }
}

void TreeNode::preorderTraversal(TreeNode *root, std::vector<int> &preorder)
{
    if (!root)
        return;

    preorder.push_back(root->val);
    TreeNode::preorderTraversal(root->left, preorder);
    TreeNode::preorderTraversal(root->right, preorder);
}

void TreeNode::postorderTraversal(TreeNode *root, std::vector<int> &postorder)
{
    if (!root)
        return;

    TreeNode::postorderTraversal(root->left, postorder);
    TreeNode::postorderTraversal(root->right, postorder);
    postorder.push_back(root->val);
}

int main()
{
    int N, root;
    scanf("%d %d", &N, &root);

    std::vector<TreeNode *> nodes(N + 1, NULL);
    while (N--)
    {
        int f, l, r;
        scanf("%d %d %d", &f, &l, &r);
        if (!nodes[f])
            nodes[f] = new TreeNode(f);
        if (l > 0 && !nodes[l])
            nodes[l] = new TreeNode(l);
        if (r > 0 && !nodes[r])
            nodes[r] = new TreeNode(r);
        nodes[f]->left = nodes[l];
        nodes[f]->right = nodes[r];
    }

    std::vector<int> inorder, preorder, postorder;

    TreeNode::inorderTraversal(nodes[root], inorder);
    TreeNode::preorderTraversal(nodes[root], preorder);
    TreeNode::postorderTraversal(nodes[root], postorder);

    for(auto node : preorder)
        printf("%d ", node);
    printf("\n");

    for(auto node : inorder)
        printf("%d ", node);
    printf("\n");

    for(auto node : postorder)
        printf("%d ", node);
    printf("\n");

    return 0;
}
```

