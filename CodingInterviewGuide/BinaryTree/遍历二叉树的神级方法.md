# **遍历二叉树的神级方法**

### 描述

分别按照二叉树先序，中序和后序打印所有的节点。

### 输入描述：

第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

### 输出描述：

输出三行分别表示二叉树的前序，中序和后序遍历。

## 示例1

```
输入：3 1
	 1 2 3
	 2 0 0
	 3 0 0

输出：1 2 3
	 2 1 3
	 2 3 1
```


```C++
#include <iostream>
#include <vector>
#include <stack>

class TreeNode
{
public:
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int val) : val(val), left(NULL), right(NULL) {}

    static void inorderTraversal(TreeNode *root, std::vector<int> &inorder);
    static void preorderTraversal(TreeNode *root, std::vector<int> &preorder);
    static void postorderTraversal(TreeNode *root, std::vector<int> &postorder);
};

void TreeNode::inorderTraversal(TreeNode *root, std::vector<int> &inorder)
{
    if (!root)
        return;

    TreeNode *curr = root;
    std::stack<TreeNode*> temp;

    while(curr || !temp.empty())
    {
        while(curr)
        {
            temp.push(curr);
            curr = curr->left;
        }
        curr = temp.top();
        temp.pop();
        inorder.push_back(curr->val);
        curr = curr->right;
    }
}

void TreeNode::preorderTraversal(TreeNode *root, std::vector<int> &preorder)
{
    if (!root)
        return;

    preorder.push_back(root->val);
    TreeNode::preorderTraversal(root->left, preorder);
    TreeNode::preorderTraversal(root->right, preorder);
}

void TreeNode::postorderTraversal(TreeNode *root, std::vector<int> &postorder)
{
    if (!root)
        return;

    TreeNode::postorderTraversal(root->left, postorder);
    TreeNode::postorderTraversal(root->right, postorder);
    postorder.push_back(root->val);
}

int main()
{
    int N, root;
    scanf("%d %d", &N, &root);

    std::vector<TreeNode *> nodes(N + 1, NULL);
    while (N--)
    {
        int f, l, r;
        scanf("%d %d %d", &f, &l, &r);
        if (!nodes[f])
            nodes[f] = new TreeNode(f);
        if (l > 0 && !nodes[l])
            nodes[l] = new TreeNode(l);
        if (r > 0 && !nodes[r])
            nodes[r] = new TreeNode(r);
        nodes[f]->left = nodes[l];
        nodes[f]->right = nodes[r];
    }

    std::vector<int> inorder, preorder, postorder;

    TreeNode::inorderTraversal(nodes[root], inorder);
    TreeNode::preorderTraversal(nodes[root], preorder);
    TreeNode::postorderTraversal(nodes[root], postorder);

    for(auto node : preorder)
        printf("%d ", node);
    printf("\n");

    for(auto node : inorder)
        printf("%d ", node);
    printf("\n");

    for(auto node : postorder)
        printf("%d ", node);
    printf("\n");

    return 0;
}
```

