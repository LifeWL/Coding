# 在二叉树中找到一个节点的后继节点

```c++
#include<iostream>
using namespace std;

class Node
{
    public:
        Node(int val)
        {
            this->val = val;
            this->left = nullptr;
            this->right = nullptr;
            this->parent = nullptr;
        }
        int val;
        Node* left;
        Node* right;
        Node* parent;
};

Node* getLeftMost(Node* head)
{
    while(head->left)
        head = head->left;
    return head;
}

Node* process1(Node* node)
{
    if(node->right)
        return getLeftMost(node->right);
    Node* parent = node->parent;
    while(parent != nullptr && node != parent->left)
    {
        node = parent;
        parent = parent->parent;
    }
    return parent;
}
Node* process(Node* node)
{
    if(node->right != nullptr)
        return getLeftMost(node->right);
    Node* parent = node->parent;
    while(parent != nullptr && node != parent->left)
    {
        node = parent;
        parent = parent->parent;
    }
    return parent;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, root;
    cin>>n>>root;
    Node* arr[n + 1];
    for(int i = 1; i <= n; ++i)
        arr[i] = new Node(i);
    
    int fa, lch, rch;
    for(int i = 0; i < n; ++i)
    {
        cin>>fa>>lch>>rch;
        if(lch != 0)
        {
            arr[fa]->left = arr[lch];
            arr[lch]->parent = arr[fa];
        }
        if(rch != 0)
        {
            arr[fa]->right = arr[rch];
            arr[rch]->parent = arr[fa];
        }
    }
    int node;
    cin>>node;
    
    Node* res = process(arr[node]);
    if(res)
        cout<<res->val<<endl;
    else
        cout<<0<<endl;
}
```

