# **二叉树的序列化**

```C++
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int val):val(val),left(nullptr),right(nullptr){}
};

void createTree( TreeNode* root, int cnt ) {
    if ( cnt == 0 )
        return;
     
    int father, leftChild, rightChild;
    scanf( "%d %d %d", &father, &leftChild, &rightChild );
 
    if ( leftChild != 0 ) {
        TreeNode* left = new TreeNode( leftChild );
        root->left = left;
        createTree( root->left, --cnt );
    }
    if ( rightChild != 0 ) {
        TreeNode* right = new TreeNode( rightChild );
        root->right = right;
        createTree( root->right, --cnt );
    }
}
void preorder(TreeNode* root)
{
    if(root==nullptr)
    {    
        cout<<"#!";
        return;
    }
    cout<<root->val<<"!";
    preorder(root->left);
    preorder(root->right);
}
void level_order(TreeNode* root)
{
    if(root==nullptr)
    {  
        cout<<"#!";
        return;
    }
    queue<TreeNode*> Q;
    Q.push(root);
    while(!Q.empty())
    {
        TreeNode* tmp=Q.front();
        Q.pop();
        if(tmp==nullptr)
        {
            cout<<"#!";
            continue;
        }
        else
        {
            cout<<tmp->val<<"!";
            Q.push(tmp->left);
            Q.push(tmp->right);
        }
    }
    
}
int main()
{
    int n,root_val;
    cin>>n>>root_val;
    TreeNode* root=new TreeNode(root_val);
    createTree(root,n);
    preorder(root);
    cout<<endl;
    level_order(root);
    cout<<endl;
}
```

