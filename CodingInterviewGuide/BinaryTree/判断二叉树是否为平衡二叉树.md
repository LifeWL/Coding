# 判断二叉树是否为平衡二叉树

### 描述

平衡二叉树的性质为: 要么是一棵空树，要么任何一个节点的左右子树高度差的绝对值不超过 1。给定一棵二叉树，判断这棵二叉树是否为平衡二叉树。

一颗树的高度指的是树的根节点到所有节点的距离中的最大值。

#### 输入描述：

第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

#### 输出描述：

如果是平衡二叉树则输出 "true"，否则输出 "false"。

### 示例1
```
输入：
    3 1
    1 2 3
    2 0 0
    3 0 0
输出：
	true
```

复制

### 示例2
```
输入：
    6 1
    1 2 3
    2 4 5
    4 6 0
    3 0 0
    5 0 0
    6 0 0
输出：
	false 
```



```c++
#include <cstdio>
#include <cmath>
#include <algorithm>

using namespace std;

const int N = 500010;

struct BST {
    int lch, rch;
} bst[N];

int n, rt;
int fa, lch, rch;

int get_height(int root, int dep, bool& flag) {
    if (!root) return dep;
    int left = get_height(bst[root].lch, dep + 1, flag);
    if (!flag) return dep;
    int right = get_height(bst[root].rch, dep + 1, flag);
    if (!flag) return dep;
    if (abs(left - right) > 1) flag = false;
    return max(left, right);
}

bool is_balance() {
    bool flag = true;
    get_height(rt, 1, flag);
    return flag;
}

int main(void) {
    scanf("%d%d", &n, &rt);
    while (n--) {
        scanf("%d%d%d", &fa, &lch, &rch);
        bst[fa].lch = lch;
        bst[fa].rch = rch;
    }
    puts(is_balance() ? "true" : "false");
    return 0;
}
```

