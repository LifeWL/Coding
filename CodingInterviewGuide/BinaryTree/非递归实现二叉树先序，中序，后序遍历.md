# 非递归实现二叉树先序，中序，后序遍历

```C++
#include <bits/stdc++.h>
using namespace std;
  
struct treeNode
{
    int val;
    struct treeNode *lch, *rch;
      
    treeNode(){}
    treeNode(int v):val(v), lch(nullptr), rch(nullptr){}
};
  
void createTree(treeNode* root)
{
    int r, lch, rch;
    scanf("%d %d %d", &r, &lch, &rch);
    if(lch){
        root->lch = new treeNode(lch);
        createTree(root->lch);
    }
    if(rch){
        root->rch = new treeNode(rch);
        createTree(root->rch);
    }
}
  
void preorder(treeNode* root)
{
    if (root == nullptr) {
        return;
    }
    stack<treeNode*> buff;
    while (!buff.empty() || root != nullptr) {
        while (root) {
            printf("%d ", root->val);
            buff.push(root);
            root = root->lch;
        }
        if (!buff.empty()) {
            root = buff.top();
            buff.pop();
            root = root->rch;
        }
    }
    printf("\n");
}
  
void inorder(treeNode* root)
{
    if (root == nullptr) {
        return;
    }
    stack<treeNode*> buff;
    while (!buff.empty() || root != nullptr) {
        while (root) {
            buff.push(root);
            root = root->lch;
        }
        if (!buff.empty()) {
            root = buff.top();
            buff.pop();
            printf("%d ", root->val);
            root = root->rch;
        }
    }
    printf("\n");
}
  
void posorder(treeNode* root)
{
    if (root == nullptr) {
        return;
    }
    stack<treeNode*> buff;
    treeNode* pre = nullptr;
    while (!buff.empty() || root) {
        while (root) {
            buff.push(root);
            root = root->lch;
        }
        if (!buff.empty()) {
            root = buff.top();
            if (!root->rch || pre == root->rch) {
                buff.pop();
                printf("%d ", root->val);
                pre = root;
                root = nullptr;
            }
            else {
                root = root->rch;
            }
        }
    }
    printf("\n");
}
  
int main()
{
    int n, r;
    scanf("%d %d", &n, &r);
    treeNode* root = new treeNode(r);
    createTree(root);
    preorder(root);
    inorder(root);
    posorder(root);
      
    return 0;
}
```

