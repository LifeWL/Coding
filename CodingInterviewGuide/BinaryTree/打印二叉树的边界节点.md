# **打印二叉树的边界节点**
## 描述

给定一颗二叉树的根节点 root，按照如下两种标准分别实现二叉树的边界节点的逆时针打印。

标准一：

1，根节点为边界节点。

2，叶节点为边界节点。

3，如果节点在其所在的层中是最左的或最右的，那么该节点也是边界节点。

标准二：

1，根节点为边界节点。

2，叶节点为边界节点。

3，树左边界延伸下去的路径为边界节点。

4，树右边界延伸下去的路径为边界节点。

ps:具体请对照样例

### 输入描述：

第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

### 输出描述：

输出两行整数分别表示按两种标准的边界节点。

## 示例1
```
输入：16 1
     1 2 3
     2 0 4
     4 7 8
     7 0 0
     8 0 11
     11 13 14
     13 0 0
     14 0 0
     3 5 6
     5 9 10
     10 0 0
     9 12 0
     12 15 16
     15 0 0
     16 0 0
     6 0 0

输出：1 2 4 7 11 13 14 15 16 12 10 6 3
	 1 2 4 7 13 14 15 16 10 6 3
	 
```




```C++
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1e6 + 10;

struct node{
    int val;
    int l = 0, r = 0;
}Node[N];
int e[N][2] = {0};

int getheight(int root){
    if(root == 0) return 0;
    return 1 + max(getheight(Node[root].l), + getheight(Node[root].r));
}

void gete(int root, int l){
    if(root == 0) return;
    if(e[l][0] == 0) e[l][0] = root;
    e[l][1] = root;
    
    gete(Node[root].l, l + 1);
    gete(Node[root].r, l + 1);
}

void print(int root, int l){
    if(root == 0) return;
    if(!Node[root].l && !Node[root].r && root != e[l][0] && root != e[l][1]){
        cout << root << " ";
    }
    print(Node[root].l, l + 1);
    print(Node[root].r, l + 1);
}

void printel(int root, bool p){
    if(root == 0) return;
    if(p || (Node[root].l == 0 && Node[root].r == 0)) cout << root << " ";
    printel(Node[root].l, p);
    printel(Node[root].r, Node[root].l == 0? p : 0);
}

void printer(int root, bool p){
    if(root == 0) return;
    printer(Node[root].l, Node[root].r == 0? p : 0);
    printer(Node[root].r, p);
    if(p || (Node[root].l == 0 && Node[root].r == 0)) cout << root << " ";
}

void printe(int root){
    if(root == 0) return ;
    cout << root << " ";
    if(Node[root].l && Node[root].r){
        printel(Node[root].l, 1);
        printer(Node[root].r, 1);
    }else{
        printe(Node[root].l ? Node[root].l : Node[root].r);
    }
}

int n, r;
int main(){
    cin >> n >> r;
    for(int i = 0; i < n; i++){
        int fa, lch, rch;
        cin >> fa >> lch >> rch;
        Node[fa].l = lch;
        Node[fa].r = rch;
    }
    int h = getheight(r);
    gete(r, 1);
    
    for(int i = 1; i <= h; i++) cout << e[i][0] << " ";
    print(r, 1);
    for(int i = h; i >= 1; i--){
        if(e[i][1] != e[i][0]) cout << e[i][1] << " ";
    }
    cout << endl;
   
    printe(r);
    
    return 0;    
}
```

