# **在二叉树中找到两个节点的最近公共祖先**

```C++
#include <iostream>
using namespace std;

typedef struct{
    int lch, rch;
}Node;
Node s[1000010];

int o1, o2;

int CF(int root){
    if(root == 0 || root == o1 || root == o2)
        return root;
    int l = CF(s[root].lch);
    int r = CF(s[root].rch);
    if(l != 0 && r != 0){
        return root;
    }
    return l != 0 ? l : r;
}

int main(){
    int n, root;
    scanf("%d %d", &n, &root);
    int fa, lch, rch;
    for(int i = 1; i <= n; i++){
        scanf("%d", &fa);
        scanf("%d %d", &s[fa].lch, &s[fa].rch);
    }
    scanf("%d %d", &o1, &o2);
    cout << CF(root) << endl;
    return 0;
}

```

